defmodule Chronik.Aggregate do
  @moduledoc """
  The `Chronik.Aggregate` is the base for all aggregates in Chronik.

  When using the `Chronik.Aggregate` module there are a number of options:
  * `shutdown_timeout` indicates `Chronik` to shutdown the aggregate GenServer
  after a number of milliseconds. Defualt value is  15 minutes.
  * `snapshot_every` indicates that a snapshot must be done on the Store
  every `snapshot_every` domain events processed. Default value is 100.

  Example:
  ```
  defmodule DomainEvents do
    defmodule CounterCreated do
      defstruct [:id]
    end

    defmodule CounterIncremented do
      defstruct [:id, :increment]
    end
  end

  defmodule Counter do
    use Chronik.Aggregate, snapshot_every: 100, shutdown_timeout: 900000

    alias DomainEvents.CounterCreated
    alias DomainEvents.CounterIncremented

    defstruct [:id]

    def handle_command({:create, id}) do
      Counter.call(id,
        fn state ->
          execute(state, &validate_create(&1, id))
        end)
    end
    def handle_command({:increment, id, increment}) do
      Counter.call(id,
        fn state ->
          execute(state, &validate_increment(&1, id, increment))
        end)
    end

    def next_state(nil, %CounterCreated{id: id}) do
      %Counter{id: id}
    end

    def next_state(%Counter{} = state, %CounterIncremented{}) do
      state
    end

    defp validate_create(nil, id) do
      %Counter{id: id}
    end
    defp validate_create(_state, _id) do
      raise "cannot create counter"
    end

    defp validate_increment(%Counter{}, id, increment) do
      %CounterIncremented{id: id, increment: increment}
    end
    defp validate_increment(_state, _id, _increment) do
      raise "cannot increment counter"
    end
  end
  ```

  The application code must implement the `handle_command` and `next_state`
  callback.

  The `Chronik.Macros` provides helper macros to define events and commands.
  """

  @typedoc """
  The `state` represents the state of an aggregate.

  Is used in the `next_state` function
  """
  @type state :: term()

  @typedoc """
  An aggregate is identified by its module and an id.
  """
  @type t :: {module(), Chronik.id}

  @doc """
  The `handle_command` is the entry point for commands on an aggregate.

  The `command` is application dependend. Throughout `Chronik`,
  commands are tagged tuples where the first element is an atom
  indicating the command to execute and the remaining elements are arguments
  to the command. E.g: `{:add_item, 13, "Elixir Book", "$15.00"}`

  Example:
  ```
  def handle_command({:add_item, id, book, price}) do
    Counter.call(id,
      fn state ->
        execute(state, &validate_add_item(&1, id, book, price))
      end)
  end

  def validate_add_item(%Cart{}, id, book, price) do
    %ItemsAdded{id: id, book: book, price: price}
  end
  def validate_add_item(nil, id, book, price) do
    raise "items cannot be added in the current state"
  end
  ```
  This command calls the `validate_add_item` to validate the command.
  If the command is valid on the given state, the function should return
  a list (or a single) of domain events.

  The return values are `:ok` indicating a success execution or `{:error, reason}`
  otherwise.
  """
  @callback handle_command(command :: Chronik.command)
    :: :ok | {:error, String.t}

  @doc """
  The `next_state` is the transition function for the aggregate. After
  command validation, the aggregate generates a number of domain events
  and then the aggregate state is updated for each event with this function.

  Note that this function can not fail since the
  domain event where generated by a valid command.
  """
  @callback next_state(state :: state, event :: Chronik.domain_event) :: state

  defmacro __using__(opts) do
    quote bind_quoted: [opts: opts] do
      @behaviour Chronik.Aggregate

      use GenServer

      alias Chronik.Aggregate.Supervisor
      alias Chronik.PubSub
      alias Chronik.Store

      require Logger

      # Fetch the configuration for the Store and the PubSub.
      {store, pub_sub} = Chronik.Config.fetch_adapters()

      # Set the modules attributes
      @name __MODULE__
      @registry Chronik.AggregateRegistry
      @store store
      @pub_sub pub_sub
      @shutdown_timeout Keyword.get(opts, :shutdown_timeout, :infinity)
      @snapshot_every Keyword.get(opts, :snapshot_every, 1000)

      ##
      ## GenServer callbacks
      ##
      @doc false
      def start_link(id) do
        GenServer.start_link(@name, id, name: via(id))
      end

      @doc false
      def init(id) do
        log(id, "starting aggregate.")
        {:ok, {id, load_from_store(id), update_timer(nil, @shutdown_timeout),
          {0, 0}}}
      end

      # The :get returns the current aggregate state.
      @doc false
      def handle_call(:get, _from, {id, state, timer, counters}) do
        {:reply, state, {id, state, timer, counters}}
      end
      # When called with a function, the aggregate executes the function in
      # the current state and if no exceptions were raised, it stores and
      # publishes the events to the PubSub.
      def handle_call(fun, _from, {id, state, timer, counters} = s)
        when is_function(fun, 1) do

        try do
          {state, []}
          |> fun.()
          |> store_and_publish(s)
        rescue
          e ->
            if state do
              {:reply, {:error, e}, s}
            else
              {:stop, :normal, {:error, e}, s}
            end
        end
      end

      @doc false
      # The shutdown timeout is implemented by auto-sending a message :shutdown
      # to the current process.
      def handle_info(:shutdown, {id, _state, _timer, _counters} = s) do
        # TODO: Do a snapshot before going down.
        log(id, "aggregate going down gracefully due to #{@shutdown_timeout}" <>
          "ms of inactivity.")
        {:stop, :normal, s}
      end

      @doc """
      The `execute` function is used to wrap the state and events in the
      `handle_command`.
      """
      def execute({state, events}, fun) do
        new_events = List.wrap(fun.(state))
        {apply_events(new_events, state), events ++ new_events}
      end

      @doc false
      def call(id, function) do
        case Registry.lookup(@registry, {@name, id}) do
          [] ->
            case Supervisor.start_aggregate(@name, id) do
              {:ok, pid} ->
                GenServer.call(pid, function)
              {:error, reason} ->
                {:error, "cannot create process for aggregate root " <>
                         "{#{@name}, #{id}}: #{inspect reason}"}
            end
          [{pid, _metadata}] -> GenServer.call(pid, function)
        end
      end

      @doc """
      The `get(id)` function returns the currente aggregate state. This should
      only be used for debugging purposes.
      """
      @spec get(Chronik.id) :: Chronik.Aggregate.state
      def get(id), do: GenServer.call(via(id), :get)

      # Internal functions
      defp via(id) do
        {:via, Registry, {@registry, {@name, id}}}
      end

      # Loads the aggregate state from the domain event store.
      # It returns the state on success or nil if there is no recorded domain
      # events for the aggregate.
      defp load_from_store(id) do
        aggregate_tuple = {@name, id}
        {version, state} =
          case @store.get_snapshot(aggregate_tuple) do
            nil ->
              log(id, "no snapshot found on the store.")
              {:all, nil}
            {version, state} = snapshot ->
              log(id, "found a snapshot on the store with version " <>
                      "#{inspect version}")
              snapshot
          end
        case @store.fetch_by_aggregate(aggregate_tuple, version) do
          {:error, _} -> state
          {:ok, _version, records} ->
            log(id, "replaynig events from #{inspect version} and on.")
            records
            |> Enum.map(&Map.get(&1, :domain_event))
            |> apply_events(state)
        end
      end

      defp apply_events(events, state) do
        Enum.reduce(events, state, &next_state(&2, &1))
      end

      defp store_and_publish({new_state, events},
        {id, _state, timer, {num_events, blocks}}) do

        log(id, "writing events to the store: #{inspect events}")
        {:ok, version, records} = @store.append({@name, id}, events)

        log(id, "broadcasting records: #{inspect records}")
        @pub_sub.broadcast(records)

        num_events = num_events + length(events)
        blocks =
          if div(num_events, @snapshot_every) > blocks do
            log(id, "saving a snapshot with version #{inspect version}")
            @store.snapshot({@name, id}, new_state, version)
            div(num_events, @snapshot_every)
          else
            blocks
          end

        {:reply, :ok, {id, new_state, update_timer(timer, @shutdown_timeout),
          {num_events, blocks}}}
      end

      defp log(id, msg) do
        Logger.debug(fn -> "[#{inspect __MODULE__}:#{inspect id}] #{msg}" end)
      end

      defp update_timer(timer, shutdown_timeout) do
        if timer,
          do: Process.cancel_timer(timer)
        if shutdown_timeout != :infinity,
          do: Process.send_after(self(), :shutdown, shutdown_timeout)
      end
    end
  end

  @doc "Starts a new aggregate given by the module `aggregate` with id `id`."
  @spec start_link(aggregate_module :: atom(), id :: Chronik.id) ::
    {:ok, pid()} | {:error, String.t}
  def start_link(aggregate_module, id) do
    aggregate_module.start_link(id)
  end
end
