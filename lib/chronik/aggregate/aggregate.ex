defmodule Chronik.Aggregate do
  @moduledoc """
  The `Chronik.Aggregate` is the base for all aggregates in Chronik.

  The module that uses `Chronik.Aggregate` module can be configured with a
  number of options:
  * `shutdown_timeout` indicates `Chronik` to shutdown the aggregate GenServer
  after a number of milliseconds. Defualt value is 15 minutes.
  * `snapshot_every` indicates that a snapshot must be done on the Store
  every `snapshot_every` domain events processed. Default value is 100.
  This configuration is looked up in the `:chronik` app under the given module.

  Example:
  ```
  defmodule DomainEvents do
    defmodule CounterCreated do
      defstruct [:id]
    end

    defmodule CounterIncremented do
      defstruct [:id, :increment]
    end
  end

  defmodule Counter do
    use Chronik.Aggregate

    alias DomainEvents.CounterCreated
    alias DomainEvents.CounterIncremented

    defstruct [:id]

    def handle_command({:create, id}) do
      Counter.call(id,
        fn state ->
          execute(state, &validate_create(&1, id))
        end)
    end
    def handle_command({:increment, id, increment}) do
      Counter.call(id,
        fn state ->
          execute(state, &validate_increment(&1, id, increment))
        end)
    end

    def handle_event(%CounterCreated{id: id}, nil) do
      %Counter{id: id}
    end

    def handle_event(%CounterIncremented{}, %Counter{} = state) do
      state
    end

    defp validate_create(nil, id) do
      %Counter{id: id}
    end
    defp validate_create(_state, _id) do
      raise "cannot create counter"
    end

    defp validate_increment(%Counter{}, id, increment) do
      %CounterIncremented{id: id, increment: increment}
    end
    defp validate_increment(_state, _id, _increment) do
      raise "cannot increment counter"
    end
  end
  ```

  The application code must implement the `handle_command` and `handle_event`
  callback.

  The `Chronik.Macros` provides helper macros to define events and commands.
  """

  @typedoc """
  The `state` represents the state of an aggregate.

  Is used in the `handle_event` function
  """
  @type state :: term()

  @typedoc """
  An aggregate is identified by its module and an id.
  """
  @type t :: {module(), Chronik.id}

  @doc """
  The `handle_command` is the entry point for commands on an aggregate.

  The `command` is application dependend. Throughout `Chronik`,
  commands are tagged tuples where the first element is an atom
  indicating the command to execute and the remaining elements are arguments
  to the command. E.g: `{:add_item, 13, "Elixir Book", "$15.00"}`

  Example:
  ```
  def handle_command({:add_item, id, book, price}) do
    Counter.call(id,
      fn state ->
        execute(state, &validate_add_item(&1, id, book, price))
      end)
  end

  def validate_add_item(%Cart{}, id, book, price) do
    %ItemsAdded{id: id, book: book, price: price}
  end
  def validate_add_item(nil, id, book, price) do
    raise "items cannot be added in the current state"
  end
  ```
  This command calls the `validate_add_item` to validate the command.
  If the command is valid on the given state, the function should return
  a list (or a single) of domain events.

  The return values are `:ok` indicating a success execution or `{:error, reason}`
  otherwise.
  """
  @callback handle_command(command :: Chronik.command)
    :: :ok | {:error, String.t}

  @doc """
  The `handle_event` is the transition function for the aggregate. After
  command validation, the aggregate generates a number of domain events
  and then the aggregate state is updated for each event with this function.

  Note that this function can not fail since the
  domain event where generated by a valid command.
  """
  @callback handle_event(event :: Chronik.domain_event, state :: state) :: state

  defmacro __using__(opts) do
    quote bind_quoted: [opts: opts] do
      @behaviour Chronik.Aggregate

      require Logger
      alias Chronik.Aggregate

      def call(id, function) do
        Aggregate.call(__MODULE__, id, function)
      end

      def execute(state_events, function) do
        Aggregate.execute(__MODULE__, state_events, function)
      end

      def get(id) do
        Aggregate.get(__MODULE__, id)
      end
    end
  end

  use GenServer
  alias Chronik.Aggregate.Supervisor
  alias Chronik.Config
  require Logger

  # Fetch the configuration for the Store and the PubSub.
  {store, pub_sub} = Config.fetch_adapters()

  # Set the modules attributes
  @registry Chronik.AggregateRegistry
  @store store
  @pub_sub pub_sub

  ##
  ## Aggregate API
  ##

  def call(module, id, function) do
    case Registry.lookup(@registry, {module, id}) do
      [] ->
        case Supervisor.start_aggregate(module, id) do
          {:ok, pid} ->
            GenServer.call(pid, {module, function})
          {:error, reason} ->
            {:error, "cannot create process for aggregate root " <>
                     "{#{module}, #{id}}: #{inspect reason}"}
        end
      [{pid, _metadata}] -> GenServer.call(pid, {module, function})
    end
  end

  @doc """
  The `execute` function is used to wrap the state and events in the
  `handle_command`.
  """
  def execute(module, {state, events}, fun) do
    new_events = List.wrap(fun.(state))
    {apply_events(new_events, state, module), events ++ new_events}
  end

  @doc """
  The `get(module, id)` function returns the currente aggregate state. This should
  only be used for debugging purposes.
  """
  @spec get(module(), Chronik.id) :: Chronik.Aggregate.state
  def get(module, id), do: GenServer.call(via(module, id), :get)

  ##
  ## GenServer API
  ##

  def start_link(module, id) do
    GenServer.start_link(__MODULE__, {module, id}, name: via(module, id))
  end

  @doc false
  def init({module, id}) do
    log(id, "starting aggregate.")
    {:ok, {id, load_from_store(module, id), update_timer(nil, module), {0, 0}}}
  end

  ##
  ## GenServer Callbacks
  ##

  # The :get returns the current aggregate state.
  @doc false
  def handle_call(:get, _from, {id, state, timer, counters}) do
    {:reply, state, {id, state, timer, counters}}
  end
  # When called with a function, the aggregate executes the function in
  # the current state and if no exceptions were raised, it stores and
  # publishes the events to the PubSub.
  def handle_call({module, fun}, _from, {_id, state, _timer, _counters} = s)
    when is_function(fun, 1) do

    {state, []}
    |> fun.()
    |> store_and_publish(s, module)
  rescue
    e ->
      if state do
        {:reply, {:error, e}, s}
      else
        {:stop, :normal, {:error, e}, s}
      end
  end

  @doc false
  # The shutdown timeout is implemented by auto-sending a message :shutdown
  # to the current process.
  def handle_info(:shutdown, {id, _state, _timer, _counters} = s) do
    # TODO: Do a snapshot before going down.
    log(id, "aggregate going down gracefully due to inactivity.")
    {:stop, :normal, s}
  end

  ##
  ## Internal functions
  ##
  defp via(module, id) do
    {:via, Registry, {@registry, {module, id}}}
  end

  # Loads the aggregate state from the domain event store.
  # It returns the state on success or nil if there is no recorded domain
  # events for the aggregate.
  defp load_from_store(module, id) do
    aggregate_tuple = {module, id}
    {version, state} =
      case @store.get_snapshot(aggregate_tuple) do
        nil ->
          log(id, "no snapshot found on the store.")
          {:all, nil}
        {version, _state} = snapshot ->
          log(id, "found a snapshot on the store with version " <>
                  "#{inspect version}")
          snapshot
      end
    case @store.fetch_by_aggregate(aggregate_tuple, version) do
      {:error, _} -> state
      {:ok, _version, records} ->
        log(id, "replaynig events from #{inspect version} and on.")
        records
        |> Enum.map(&Map.get(&1, :domain_event))
        |> apply_events(state, module)
    end
  end

  defp apply_events(events, state, module) do
    Enum.reduce(events, state, &module.handle_event/2)
  end

  defp store_and_publish({new_state, events},
    {id, _state, timer, {num_events, blocks}}, module) do

    log(id, "writing events to the store: #{inspect events}")
    {:ok, version, records} = @store.append({module, id}, events)

    log(id, "broadcasting records: #{inspect records}")
    @pub_sub.broadcast(records)

    num_events = num_events + length(events)
    blocks =
      if div(num_events, get_snapshot_every(module)) > blocks do
        log(id, "saving a snapshot with version #{inspect version}")
        @store.snapshot({module, id}, new_state, version)
        div(num_events, get_snapshot_every(module))
      else
        blocks
      end

    {:reply, :ok, {id, new_state, update_timer(timer, module),
      {num_events, blocks}}}
  end

  defp log(id, msg) do
    Logger.debug(fn -> "[#{inspect __MODULE__}:#{inspect id}] #{msg}" end)
  end

  defp update_timer(timer, module) do
    shutdown_timeout = get_shutdown_timeout(module)

    if timer, do: Process.cancel_timer(timer)

    if shutdown_timeout != :infinity,
      do: Process.send_after(self(), :shutdown, shutdown_timeout)
  end

  defp get_shutdown_timeout(module),
    do: Config.get_config(module, :shutdown_timeout, 15 * 1000 * 60)

  defp get_snapshot_every(module),
    do: Config.get_config(module, :snapshot_every, 100)

end
